# pat

* interface
  * to_string(int)
  * std::stoi()
  * isdigit(char)
  * pow(int radix,int e)
  * *max_element(sting.begin(),string.end())
  * set.find() == set.end()//not find in set







* next 
  * 1014
  * 1018
  * 1026
    * 18和26都是队列模拟题，
    * 建立好结构体，
    * 按入队，处理问题，出队的思路去处理
  * 1045
    * 这一题和 leetcode 1143最长公共距离类似
    * 这一题不要求与子序列完全相同
  * 1044
    * 子串的和是否大于等于一个数
      * 构造一个递增有序序列
      * 对该序列做n次二分查找，二分查找的每次循环中计算[i,mid]之间的和
  * 1057求第k小
    * 大根堆
      * 不用预先分配内存
      * 但不能对元素进行删除操作
    * 树状数组
      * 需要预先分配一段数组空间
      * 允许对元素进行删除操作
      * 允许重复元素
  * 1060
  * 1067
    * 这题含义是交换0所在位置和其他位置的数，达到排序的效果
    * 贪心思想：每一次交换都要保证一个数落入了最终位置
  * 1068
    * 0/1背包问题
    * 且choice[i] [j]记录了dp[j]的更新过程
  * 1081
    * 最大公约数
  * 1085
    * for循环 + 折半查找
    * 这一题折半查找的思想和1044一样
  * 1087
    * dijkstra求最短路径和前驱节点pre
    * 来利用pre和dfs求得路径
  * 1089
    * 归并排序
      * https://www.cnblogs.com/chengxiao/p/6194356.html
        * 归并排序可以理解为分治的思想
          * 分: 递归向下分为更小的序列
          * 治: 将两两相邻的有序序列合并为一个有序序列
            * 两两相邻的序列的大小变化为k*=2(初始时k=1)
  * 1093
    * 统计串中有多少个PAT子序列





* code

  * ```
    //将10进制的n转化为d进制
    int toD(int n, int d)
    {
    	vector<int> v;//把n的每一位存储到v中
    	do {
    		int y = n % d;
    		n = n / d;
    
    		v.insert(v.begin(),y);
    	} while (n != 0);
    
    	for (int i = 0; i < v.size(); i++)
    	{
    		n = n * d + v[i];//注意这种写法；另外一种写法是考虑d,d^2,d^3,d^4...
    	}
    
    	return n;
    
    }
    ```

  * ```
    bool isPrime(int n)
    {
    	if (n <= 1)
    		return false;
    	for (int i = 2; i*i <= n; i++)
    		if (n%i == 0)
    			return false;
    
    	return true;
    }
    ```

  * ```
    //整数由两个字符串表示，计算它们的和
    		int jin = 0;
    		string t;
    		for (int i = s[0].size() - 1; i >= 0; i--)
    		{
    			int n = s[0][i] - '0' + s[1][i] - '0';
    			int y = (n + jin) % 10;
    			jin = (n + jin) / 10;
    			t.push_back(y+'0');
    		}
    		if (jin)
    			t.push_back(jin + '0');
    		reverse(t.begin(),t.end());
    ```
  
    
    
  * ```
    
    ```
  
    





* leetcode
  * 动态规划
    * 以第i个为结尾的dp，dp[n]通常不是最后所求







* 公司加上人数

* sc

  * RAII去掉

  * 函数萃取

    * 可将成员函数，普通函数，lambda表达式封装成std::function保存到内部map中

      * 利用类模板抽象出函数返回类型和参数列表，以此可以新建一个通用的std::function类型，用以存储不同签名的函数

      * ```
        template <typename Ret, typename... Args>
        struct FunctionTraits<Ret(Args...)>
        {
            using stl_function_type = std::function<Ret(Args...)>;
        };
        ```

  * 把类型擦除去掉

  * 模板单例变为线程安全的模板单例

    * 用到了静态局部对象只会初始化一次的特点

    * ```
      template <typename T>
      class Singleton: noncopyable
      {
          public:
              Singleton() = delete;
              ~Singleton() = delete;
              static T& instance()
              {
                  static T t;
                  return t;
              }
      };
      ```

  * qt的事件循环

    * 和epoll类似，都是事件通知机制，即当一个事件(如文件描述符可读可写的时候)通知应用程序；而不是应用程序通过轮询的方式去检查。
    * qt的事件机制抽象层级更高，支持更多的事件比如键盘事件和自定义事件，也更方便使用。
    * 另外使用事件机制还可以用来线程之间的通信
    
  * 路由表更新出错去掉

  * new失败的异常处理过程

    * new 失败的话会抛出一个bad_alloc的异常，默认的handler不会做任何处理
    * 给buffer类设置自定义的handler
      * 是一个线程，会预先开辟一段10个buffer内存空间
      * 当出现new失败时候，弹出一个供程序使用

  * 滑动窗口

    * 从ue来的数据有时会出现不完整的情况，即一次read不会读到一个完整的包
      * 内部使用两个指针，头指针指向包头，尾指针指向当前数据的末端，当尾指针指向包尾标识符后，再开始包头和包尾之间的数据

  * 去掉联动表格

  * 利用crc16table解决数据校验缓慢的问题

    * 在收到hdlc协议的包后，需要做数据校验，之前的处理需要多数据转化为按位存储后进行多次的求模运算，非常耗时
    * 建立一个hash表，值对应的就是对应下标的crc校验结果，一共256个，对应的是按字节处理
    * 多大的数据，时间提高的了多少





* mts
  * 用例文件升级（放到最后）
    * 用例文件格式是，文件头+结构体信息
    * 用例升级就是有些结构体内部会增删改查，需要将这些变化对应到用例文件中
      * 将100多个结构体信息包括成员类型，名称，字段大小全部先存储在一个xml文件中
        * 收集协议栈的头文件(10个左右)
        * 解析头文件存储到xml文件中
      * 利用这个xml文件来对比找出新旧结构体之间的区别，再将这些差别更新到用例文件中
  * 使用工厂模式重构



* 文本编辑器

  * 将与文本编辑的所有操作全部封装成命令模式进行处理，保障插入删除替换对齐等

    * 基类主要提高两个接口redo和undo,分别执行编辑操作和撤销编辑操作
      * 同时还可依次执行多个操作的撤销和还原
        * 先发生的编辑操作，总是后才撤销的
        * **符合先进后出的特点**
    * 外部类维护了两个重要的数据结构，undo**栈**和redo栈
      * 比如当用户插入文本时
        * 将这个插入文本对象push到undo栈
        * 并调用该对象的redo接口
      * 要做撤销时
        * 从undo栈的队头pop出一个对象，调用undo接口
        * 并将该对象push到redo栈
      * 要做还原时
        * 从redo栈pop出一个对象，调用redo接口
        * 并将该对象push到undo栈
    * 可以提一句是从极客事件里王争的<<数据结构与算法之美>>获取到的

  * 大文本加载优化

    * 当一次价值超过100M的纯文本内容时，会出现10秒左右的等待时间，文件编辑器才会完成加载

      * 测试发现，加载操作是一个阻塞调用过程，30M时界面就会出现卡顿现象

      * 使用qt的事件循环机制+分段加载的方式，每次抛出一个加载10M文件内容的事件，editor介绍到这个事件后

        再做插入文本的处理动作

      * 加载过程中不允许由遍及操作，可以查看

    * 大文本查找和替换也是用的同样的思路

      * 不全部查找整个文本的内容，而只是先查找当前窗口可见范围内的文本，并高亮显示
      * 同时会显示查找到的个数

    

    

    

    

* 磐优
  * 去掉第二个
  * 第一个位置改成FTPServer，标准的协议
    * 麒麟软件和qt都没有支持ftpserver
  * 先讲一下标准的ftp协议

